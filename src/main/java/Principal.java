
import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */

/**
 *
 *
 */
public class Principal extends javax.swing.JFrame {
    
    static Scanner entrada = new Scanner(System.in);
    static ArrayList<String> archivoTexto = new ArrayList<>();
    static ArrayList<String> patterns = new ArrayList<>();
    static ArrayList<String> arrayResultadoLineaYPosicion = new ArrayList<>();
    static ArrayList<String> resultadoFinal = new ArrayList<>();
    ArrayList<String> resultados= new ArrayList<>();
    static String textoIngresado;
    static int numeroDePatrones;
    static ArrayList<String> acum_res = new ArrayList<>();
    DefaultListModel modelo=new DefaultListModel();
    DefaultListModel modeloresultados=new DefaultListModel();
   
    /**
     * Creates new form Principal
     */
    public Principal() {
        initComponents();
       btn_importar.setVisible(false);
       btn_modificar.setVisible(false);
       txt_ingresar.setVisible(false);
       btn_agregar.setVisible(false);
       lst_patrones.setModel(modelo);
       lst_resultados.setModel(modeloresultados);
        setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        jPanel1 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        jPanel5 = new javax.swing.JPanel();
        rbtn_importar = new javax.swing.JRadioButton();
        rbtn_ingresar = new javax.swing.JRadioButton();
        pnl_importar = new javax.swing.JPanel();
        btn_importar = new javax.swing.JToggleButton();
        btn_agregar = new javax.swing.JButton();
        txt_ingresar = new javax.swing.JTextField();
        btn_modificar = new javax.swing.JButton();
        jPanel4 = new javax.swing.JPanel();
        jPanel3 = new javax.swing.JPanel();
        rbtn_brute = new javax.swing.JRadioButton();
        rbtn_kmp = new javax.swing.JRadioButton();
        rbtn_booyer = new javax.swing.JRadioButton();
        rbtn_all = new javax.swing.JRadioButton();
        jPanel6 = new javax.swing.JPanel();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        lst_resultados = new javax.swing.JList<>();
        jPanel7 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        lst_patrones = new javax.swing.JList<>();
        txt_patron = new javax.swing.JTextField();
        btn_ingresar_patron = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jButton3 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setUndecorated(true);
        setResizable(false);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Texto"));
        jPanel2.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder("obtener texto mediante"));

        buttonGroup1.add(rbtn_importar);
        rbtn_importar.setText("Importar txt");
        rbtn_importar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtn_importarActionPerformed(evt);
            }
        });

        buttonGroup1.add(rbtn_ingresar);
        rbtn_ingresar.setText("Digitar texto");
        rbtn_ingresar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtn_ingresarActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel5Layout = new javax.swing.GroupLayout(jPanel5);
        jPanel5.setLayout(jPanel5Layout);
        jPanel5Layout.setHorizontalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(rbtn_ingresar)
                    .addComponent(rbtn_importar))
                .addContainerGap(81, Short.MAX_VALUE))
        );
        jPanel5Layout.setVerticalGroup(
            jPanel5Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel5Layout.createSequentialGroup()
                .addComponent(rbtn_importar)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(rbtn_ingresar))
        );

        jPanel2.add(jPanel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(16, 27, -1, -1));

        pnl_importar.setBorder(javax.swing.BorderFactory.createTitledBorder("Tools"));
        pnl_importar.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        btn_importar.setText("seleccionar el archivo txt a importar");
        btn_importar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_importarActionPerformed(evt);
            }
        });
        pnl_importar.add(btn_importar, new org.netbeans.lib.awtextra.AbsoluteConstraints(120, 50, -1, -1));

        btn_agregar.setText("agregar");
        btn_agregar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_agregarActionPerformed(evt);
            }
        });
        pnl_importar.add(btn_agregar, new org.netbeans.lib.awtextra.AbsoluteConstraints(300, 50, -1, -1));

        txt_ingresar.setText(" ");
        pnl_importar.add(txt_ingresar, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 20, 280, 60));

        btn_modificar.setText("modificar");
        btn_modificar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_modificarActionPerformed(evt);
            }
        });
        pnl_importar.add(btn_modificar, new org.netbeans.lib.awtextra.AbsoluteConstraints(300, 20, -1, -1));

        jPanel2.add(pnl_importar, new org.netbeans.lib.awtextra.AbsoluteConstraints(210, 30, 380, 90));

        jPanel1.add(jPanel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 30, 610, 130));

        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder("Algoritmos de Busqueda"));

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder("Selecciona el algoritmo de busqueda a utilizar"));
        jPanel3.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        buttonGroup2.add(rbtn_brute);
        rbtn_brute.setText("Fuerza Bruta");
        rbtn_brute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtn_bruteActionPerformed(evt);
            }
        });
        jPanel3.add(rbtn_brute, new org.netbeans.lib.awtextra.AbsoluteConstraints(12, 23, -1, -1));

        buttonGroup2.add(rbtn_kmp);
        rbtn_kmp.setText("KMP");
        rbtn_kmp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtn_kmpActionPerformed(evt);
            }
        });
        jPanel3.add(rbtn_kmp, new org.netbeans.lib.awtextra.AbsoluteConstraints(160, 20, -1, -1));

        buttonGroup2.add(rbtn_booyer);
        rbtn_booyer.setText("Boyer Moore");
        rbtn_booyer.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtn_booyerActionPerformed(evt);
            }
        });
        jPanel3.add(rbtn_booyer, new org.netbeans.lib.awtextra.AbsoluteConstraints(280, 20, -1, -1));

        buttonGroup2.add(rbtn_all);
        rbtn_all.setText("utilizar todas");
        rbtn_all.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rbtn_allActionPerformed(evt);
            }
        });
        jPanel3.add(rbtn_all, new org.netbeans.lib.awtextra.AbsoluteConstraints(420, 20, -1, -1));

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel4Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 566, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(23, Short.MAX_VALUE))
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        jPanel1.add(jPanel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 290, 611, 100));

        jPanel6.setBorder(javax.swing.BorderFactory.createTitledBorder("Resultados obtenidos"));

        jButton1.setText("exportar");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("salir");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jScrollPane3.setViewportView(lst_resultados);

        javax.swing.GroupLayout jPanel6Layout = new javax.swing.GroupLayout(jPanel6);
        jPanel6.setLayout(jPanel6Layout);
        jPanel6Layout.setHorizontalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel6Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 497, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel6Layout.setVerticalGroup(
            jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel6Layout.createSequentialGroup()
                .addGroup(jPanel6Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 77, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(jPanel6Layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(jButton1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButton2)))
                .addContainerGap(21, Short.MAX_VALUE))
        );

        jPanel1.add(jPanel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 420, 610, 120));

        jPanel7.setBorder(javax.swing.BorderFactory.createTitledBorder("Ingreso de patrones a buscar"));
        jPanel7.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jScrollPane2.setViewportView(lst_patrones);

        jPanel7.add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(320, 30, 160, 40));

        txt_patron.setText(" ");
        txt_patron.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                txt_patronMouseClicked(evt);
            }
        });
        txt_patron.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txt_patronActionPerformed(evt);
            }
        });
        jPanel7.add(txt_patron, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 30, 150, 30));

        btn_ingresar_patron.setText("Agragar patron");
        btn_ingresar_patron.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_ingresar_patronActionPerformed(evt);
            }
        });
        jPanel7.add(btn_ingresar_patron, new org.netbeans.lib.awtextra.AbsoluteConstraints(180, 30, -1, -1));

        jLabel1.setText("patrones ingresados :");
        jPanel7.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(310, 10, -1, -1));

        jButton3.setText("borrar patrones");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });
        jPanel7.add(jButton3, new org.netbeans.lib.awtextra.AbsoluteConstraints(490, 50, -1, -1));

        jPanel1.add(jPanel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 180, 610, 90));

        getContentPane().add(jPanel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 10, 640, 550));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void rbtn_importarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtn_importarActionPerformed
       if(rbtn_importar.isSelected()){
           btn_importar.setVisible(true);
           txt_ingresar.setVisible(false);
           btn_agregar.setVisible(false);
           
       }
    }//GEN-LAST:event_rbtn_importarActionPerformed

    private void rbtn_booyerActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtn_booyerActionPerformed
        if(rbtn_booyer.isSelected()){
            for(String patron : patterns){//Mediante un ciclo for, el string "patron" va a obtener uno a uno los valores dentro del array "patrones"
                                    long tiempoInicio = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoInicio"
                                    for(int f=0; f<archivoTexto.size();f++){//Mediante un ciclo for se recorre el array "archivoTexto", la variable f sirve para determinar la linea en que se encuentra el patrón
                                        //Se llama al metodo busquedaBoyerMoore al que se envia el dato del array "archivoTexto" y el patron
                                        //El resultado (la posición o posiciones de la coincidencia) se asigna al array "resultados"
                                        resultados=busquedaBoyerMoore(archivoTexto.get(f).toCharArray(), patron.toCharArray());
                                        for(int s =0; s<resultados.size();s++){//Mediante un ciclo for, se recorre el array "resultados"
                                            //Se agrega la linea f en que se encontró la coincidencia, junto con la posicion o posiciones de la misma
                                            //Todo esto (linea y posicion) se asigna al array "arrayResultadoLineaYPosicion"
                                            arrayResultadoLineaYPosicion.add("Se encontró en la linea " + (f+1) + " en la posicion " + resultados.get(s));
                                        }
                                    }
                                    long tiempoFinal = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoFinal"
                                    //Se abre una ventana de mensaje que muestra el número total de coincidencias encontrdas, junto con el patron que se utilizó y el tiempo total de ejecucion
                                    acum_res.add("Para el algoritmo Boyer Moore se encontraron " + arrayResultadoLineaYPosicion.size() +
                                            " coincidencias con el patron " + patron + " y la busqueda tomo " + (tiempoFinal-tiempoInicio) + " milisegundos");
                                    //Mediante un ciclo for se agrega la cantidad de coincidencias, detallando donde se encuentra cada una (linea y posicion)
                                    //Todos estos datos se asignan a un array "resultadoFinal"
                                    for(int v=0; v<arrayResultadoLineaYPosicion.size();v++){
                                        acum_res.add("La coincidencia " + (v+1) + " " + arrayResultadoLineaYPosicion.get(v) + "\n");
                                    }
                                    
                                    resultadoFinal.clear(); //Se borran los datos del array "resultadoFinal"
                                    arrayResultadoLineaYPosicion.clear(); //Se borran los datos del array "arrayResultadoLineaYPosicion"


                                }
                                
            modeloresultados.removeAllElements();
                                     for (int i = 0; i < acum_res.size(); i++) {
                                         modeloresultados.addElement(acum_res.get(i));
                                     }
                                    lst_resultados.setModel(modeloresultados);
                                    acum_res.clear(); 
        }
    }//GEN-LAST:event_rbtn_booyerActionPerformed

    private void rbtn_allActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtn_allActionPerformed
        if(rbtn_all.isSelected()){
            for(String patron : patterns){
                                    //-----------------------------------------------------------------------------------------------------------------------------------------------
                                    //FUERZA BRUTA
                                    //----------------------------------------------------------------------------------------------------------------------------------------
                                    long tiempoInicio = System.currentTimeMillis(); //Se asigna la hora actual del sistema en milisegundos a la variable "tiempoInicio"
                                    for(int f=0; f<archivoTexto.size();f++){ //Mediante un ciclo for se recorre el array "archivoTexto", la variable f sirve para determinar la linea en que se encuentra el patrón
                                        //Se llama al metodo fuerzaBruta1 al que se envia el dato del array "archivoTexto" y el patron
                                        //El resultado (la posición o posiciones de la coincidencia) se asigna al array "resultados"
                                        resultados=busquedaFuerzaBruta(archivoTexto.get(f),patron);
                                        for(int s =0; s<resultados.size();s++){ //Mediante un ciclo for, se recorre el array "resultados"
                                            //Se agrega la linea f en que se encontró la coincidencia, junto con la posicion o posiciones de la misma
                                            //Todo esto (linea y posicion) se asigna al array "arrayResultadoLineaYPosicion"
                                            arrayResultadoLineaYPosicion.add("Se encontró en la linea " + (f+1) + " en la posicion " + resultados.get(s));
                                        }
                                    }
                                    long tiempoFinal = System.currentTimeMillis(); //Se asigna la hora actual del sistema en milisegundos a la variable "tiempoFinal"
                                    long tiempoFuerzaBruta = tiempoFinal-tiempoInicio;
                                    //Se abre una ventana de mensaje que muestra el número total de coincidencias encontrdas, junto con el patron que se utilizó y el tiempo total de ejecucion
                                    acum_res.add( "Para el algoritmo Fuerza Bruta se encontraron " + arrayResultadoLineaYPosicion.size() +
                                            " coincidencias con el patron " + patron + " y la busqueda tomo " + (tiempoFinal-tiempoInicio) + " milisegundos");
                                    //Mediante un ciclo for se agrega la cantidad de coincidencias, detallando donde se encuentra cada una (linea y posicion)
                                    //Todos estos datos se asignan a un array "resultadoFinal"
                                    for(int v=0; v<arrayResultadoLineaYPosicion.size();v++){
                                        acum_res.add("La coincidencia " + (v+1) + " " + arrayResultadoLineaYPosicion.get(v) + "\n");
                                    }
                                    
                                    resultadoFinal.clear(); //Se borran los datos del array "resultadoFinal"
                                    arrayResultadoLineaYPosicion.clear(); //Se borran los datos del array "arrayResultadoLineaYPosicion"



                                    //----------------------------------------------------------------------------------------------------------------------------------------
                                    //KMP
                                    //-----------------------------------------------------------------------------------------------------------------------------------------
                                    long tiempoInicio2 = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoInicio"
                                    for(int f=0; f<archivoTexto.size();f++){//Mediante un ciclo for se recorre el array "archivoTexto", la variable f sirve para determinar la linea en que se encuentra el patrón
                                        //Se llama al metodo findKMP al que se envia el dato del array "archivoTexto" y el patron
                                        //El resultado (la posición o posiciones de la coincidencia) se asigna al array "resultados"
                                        resultados=busquedaKMP(archivoTexto.get(f).toCharArray(),patron.toCharArray());
                                        for(int s =0; s<resultados.size();s++){//Mediante un ciclo for, se recorre el array "resultados"
                                            //Se agrega la linea f en que se encontró la coincidencia, junto con la posicion o posiciones de la misma
                                            //Todo esto (linea y posicion) se asigna al array "arrayResultadoLineaYPosicion"
                                            arrayResultadoLineaYPosicion.add("Se encontró en la linea " + (f+1) + " en la posicion " + resultados.get(s));
                                        }
                                    }
                                    long tiempoFinal2 = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoFinal"
                                    long tiempoKMP = tiempoFinal2-tiempoInicio2;
                                    //Se abre una ventana de mensaje que muestra el número total de coincidencias encontrdas, junto con el patron que se utilizó y el tiempo total de ejecucion
                                    acum_res.add("Para el algoritmo KMP se encontraron " + arrayResultadoLineaYPosicion.size() +
                                            " coincidencias con el patron " + patron + " y la busqueda tomo " + (tiempoFinal2-tiempoInicio2) + " milisegundos");
                                    //Mediante un ciclo for se agrega la cantidad de coincidencias, detallando donde se encuentra cada una (linea y posicion)
                                    //Todos estos datos se asignan a un array "resultadoFinal"
                                    for(int v=0; v<arrayResultadoLineaYPosicion.size();v++){
                                        acum_res.add("La coincidencia " + (v+1) + " " + arrayResultadoLineaYPosicion.get(v) + "\n");
                                    }
                                    
                                    resultadoFinal.clear();//Se borran los datos del array "resultadoFinal"
                                    arrayResultadoLineaYPosicion.clear();//Se borran los datos del array "arrayResultadoLineaYPosicion"




                                    //-----------------------------------------------------------------------------------------------------------------------------------
                                    //BOYER MOORE
                                    //----------------------------------------------------------------------------------------------------------------------------------------------
                                    long tiempoInicio3 = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoInicio"
                                    for(int f=0; f<archivoTexto.size();f++){//Mediante un ciclo for se recorre el array "archivoTexto", la variable f sirve para determinar la linea en que se encuentra el patrón
                                        //Se llama al metodo busquedaBoyerMoore al que se envia el dato del array "archivoTexto" y el patron
                                        //El resultado (la posición o posiciones de la coincidencia) se asigna al array "resultados"
                                        resultados=busquedaBoyerMoore(archivoTexto.get(f).toCharArray(), patron.toCharArray());
                                        for(int s =0; s<resultados.size();s++){//Mediante un ciclo for, se recorre el array "resultados"
                                            //Se agrega la linea f en que se encontró la coincidencia, junto con la posicion o posiciones de la misma
                                            //Todo esto (linea y posicion) se asigna al array "arrayResultadoLineaYPosicion"
                                            arrayResultadoLineaYPosicion.add("Se encontró en la linea " + (f+1) + " en la posicion " + resultados.get(s));
                                        }
                                    }
                                    long tiempoFinal3 = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoFinal"
                                    long tiempoBoyerMoore = tiempoFinal3-tiempoInicio3;
                                    //Se abre una ventana de mensaje que muestra el número total de coincidencias encontrdas, junto con el patron que se utilizó y el tiempo total de ejecucion
                                    acum_res.add( "Para el algoritmo Boyer Moore se encontraron " + arrayResultadoLineaYPosicion.size() +
                                            " coincidencias con el patron " + patron + " y la busqueda tomo " + (tiempoFinal3-tiempoInicio3) + " milisegundos");
                                    //Mediante un ciclo for se agrega la cantidad de coincidencias, detallando donde se encuentra cada una (linea y posicion)
                                    //Todos estos datos se asignan a un array "resultadoFinal"
                                    for(int v=0; v<arrayResultadoLineaYPosicion.size();v++){
                                        acum_res.add("La coincidencia " + (v+1) + " " + arrayResultadoLineaYPosicion.get(v) + "\n");
                                    }
                                    resultadoFinal.clear();//Se borran los datos del array "resultadoFinal"
                                    arrayResultadoLineaYPosicion.clear();//Se borran los datos del array "arrayResultadoLineaYPosicion"
                                    ArrayList<String> tiemposEjecucion = new ArrayList<>(); //Se crea un array "tiemposEjecucion" que guarda los tiempos de ejecucion de los algoritmos
                                    //el tiempo de ejecucion y nombre de cada algoritmo se agrega al array
                                    tiemposEjecucion.add(tiempoFuerzaBruta + " Fuerza Bruta");
                                    tiemposEjecucion.add(tiempoKMP + " KMP");
                                    tiemposEjecucion.add(tiempoBoyerMoore + "  Boyer Moore");
                                    Collections.sort(tiemposEjecucion); //se ordenan los tiempos de menor a mayor
                                    String mejorAlgoritmo = tiemposEjecucion.get(0); //se asigna el primer valor del array al string "mejorAlgoritmo"
                                    //Finalmente se muestra una ventana describiendo el patron y el algoritmo que lo ejecutó en el menor tiempo, para ello se utiliza el método substring
                                    acum_res.add("Para buscar el patron " + patron + " el mejor algoritmo fue " + mejorAlgoritmo.substring(3,mejorAlgoritmo.length()));
                                }
            
                modeloresultados.removeAllElements();
                for (int j = 0; j < acum_res.size(); j++) {
                    modeloresultados.addElement(acum_res.get(j));
                }
                lst_resultados.setModel(modeloresultados);
                acum_res.clear();
            
                                archivoTexto.clear();
        }
    }//GEN-LAST:event_rbtn_allActionPerformed

    private void btn_importarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_importarActionPerformed
         archivoTexto.clear();
        JFileChooser fc=new JFileChooser();
        fc.showOpenDialog(null);
        File archivo = fc.getSelectedFile();
        try {
            FileReader fr = new FileReader (archivo);
            BufferedReader br =new BufferedReader(fr);
            entrada = new Scanner(archivo);
            while(entrada.hasNext()){
                archivoTexto.add(entrada.nextLine());
            }
            JOptionPane.showMessageDialog(null, "Archivo leido correctamente");
        } catch (Exception e) {
            
            System.out.println(""+e);
        }
        
    }//GEN-LAST:event_btn_importarActionPerformed

    private void rbtn_bruteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtn_bruteActionPerformed
       
        if(rbtn_brute.isSelected()){
            for (int i = 0; i < patterns.size(); i++) {
                long tiempoInicio = System.currentTimeMillis(); //Se asigna la hora actual del sistema en milisegundos a la variable "tiempoInicio"
                for(int f=0; f<archivoTexto.size();f++){ //Mediante un ciclo for se recorre el array "archivoTexto", la variable f sirve para determinar la linea en que se encuentra el patrón
                //Se llama al metodo fuerzaBruta1 al que se envia el dato del array "archivoTexto" y el patron
                //El resultado (la posición o posiciones de la coincidencia) se asigna al array "resultados"
                resultados=busquedaFuerzaBruta(archivoTexto.get(f),patterns.get(i));
                for(int s =0; s<resultados.size();s++){ //Mediante un ciclo for, se recorre el array "resultados"
                    //Se agrega la linea f en que se encontró la coincidencia, junto con la posicion o posiciones de la misma
                    //Todo esto (linea y posicion) se asigna al array "arrayResultadoLineaYPosicion"
                    arrayResultadoLineaYPosicion.add("Se encontró en la linea " + (f+1) + " en la posicion " + resultados.get(s));
                    }
                }
                long tiempoFinal = System.currentTimeMillis(); //Se asigna la hora actual del sistema en milisegundos a la variable "tiempoFinal"
                //Se abre una ventana de mensaje que muestra el número total de coincidencias encontrdas, junto con el patron que se utilizó y el tiempo total de ejecucion
                acum_res.add("Para el algoritmo Fuerza Bruta se encontraron " + arrayResultadoLineaYPosicion.size() +
                " coincidencias con el patron " + patterns.get(i) + " y la busqueda tomo " + (tiempoFinal-tiempoInicio) + " milisegundos");
                //Mediante un ciclo for se agrega la cantidad de coincidencias, detallando donde se encuentra cada una (linea y posicion)
                //Todos estos datos se asignan a un array "resultadoFinal"
                for(int v=0; v<arrayResultadoLineaYPosicion.size();v++){
                    acum_res.add("La coincidencia " + (v+1) + " " + arrayResultadoLineaYPosicion.get(v) + "\n");
                }
                                    
                
                resultadoFinal.clear(); //Se borran los datos del array "resultadoFinal"
                arrayResultadoLineaYPosicion.clear(); //Se borran los datos del array "arrayResultadoLineaYPosicion"
                                                                                                            
            }
                modeloresultados.removeAllElements();
                for (int j = 0; j < acum_res.size(); j++) {
                    modeloresultados.addElement(acum_res.get(j));
                }
                lst_resultados.setModel(modeloresultados);
                acum_res.clear();
                   
        }
    
        
    }//GEN-LAST:event_rbtn_bruteActionPerformed

    private void rbtn_ingresarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtn_ingresarActionPerformed
        if(rbtn_ingresar.isSelected()){
           btn_importar.setVisible(false);
           txt_ingresar.setVisible(true);
           btn_agregar.setVisible(true);
       }
        
        
    }//GEN-LAST:event_rbtn_ingresarActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        File exportar=new File("C:\\");
        FileWriter escribir;
        PrintWriter linea;
        if(!exportar.exists()){
            try {
            
        } catch (Exception e) {
            System.err.println("No se pudo guardar");
        }
        }
        
        
        
        
    }//GEN-LAST:event_jButton1ActionPerformed

    private void txt_patronActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txt_patronActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_txt_patronActionPerformed

    private void btn_ingresar_patronActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_ingresar_patronActionPerformed
     
        patterns.add(txt_patron.getText());
        modelo.removeAllElements();
        for (int i = 0; i < patterns.size(); i++) {
            modelo.addElement(patterns.get(i));
        }
        
        txt_patron.setText("");
        modeloresultados.clear();
        acum_res.clear();
        lst_resultados.setModel(modeloresultados);
        
    }//GEN-LAST:event_btn_ingresar_patronActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        System.exit(0);
    }//GEN-LAST:event_jButton2ActionPerformed

    private void txt_patronMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_txt_patronMouseClicked
        // TODO add your handling code here:
    }//GEN-LAST:event_txt_patronMouseClicked

    private void rbtn_kmpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rbtn_kmpActionPerformed
       if(rbtn_kmp.isSelected()){
           
           for(String patron : patterns){//Mediante un ciclo for, el string "patron" va a obtener uno a uno los valores dentro del array "patrones"
                                    long tiempoInicio = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoInicio"
                                    for(int f=0; f<archivoTexto.size();f++){//Mediante un ciclo for se recorre el array "archivoTexto", la variable f sirve para determinar la linea en que se encuentra el patrón
                                        //Se llama al metodo findKMP al que se envia el dato del array "archivoTexto" y el patron
                                        //El resultado (la posición o posiciones de la coincidencia) se asigna al array "resultados"
                                        resultados=busquedaKMP(archivoTexto.get(f).toCharArray(),patron.toCharArray());
                                        for(int s =0; s<resultados.size();s++){//Mediante un ciclo for, se recorre el array "resultados"
                                            //Se agrega la linea f en que se encontró la coincidencia, junto con la posicion o posiciones de la misma
                                            //Todo esto (linea y posicion) se asigna al array "arrayResultadoLineaYPosicion"
                                            arrayResultadoLineaYPosicion.add("Se encontró en la linea " + (f+1) + " en la posicion " + resultados.get(s));
                                        }
                                    }
                                    long tiempoFinal = System.currentTimeMillis();//Se asigna la hora actual del sistema en milisegundos a la variable "tiempoFinal"
                                    //Se abre una ventana de mensaje que muestra el número total de coincidencias encontrdas, junto con el patron que se utilizó y el tiempo total de ejecucion
                                    acum_res.add("Para el algoritmo KMP se encontraron " + arrayResultadoLineaYPosicion.size() +
                                            " coincidencias con el patron " + patron + " y la busqueda tomo " + (tiempoFinal-tiempoInicio) + " milisegundos");
                                    //Mediante un ciclo for se agrega la cantidad de coincidencias, detallando donde se encuentra cada una (linea y posicion)
                                    //Todos estos datos se asignan a un array "resultadoFinal"
                                    for(int v=0; v<arrayResultadoLineaYPosicion.size();v++){
                                        acum_res.add("La coincidencia " + (v+1) + " " + arrayResultadoLineaYPosicion.get(v) + "\n");
                                    }
                                   
                                    resultadoFinal.clear(); //Se borran los datos del array "resultadoFinal"
                                    arrayResultadoLineaYPosicion.clear(); //Se borran los datos del array "arrayResultadoLineaYPosicion"


     }
     modeloresultados.removeAllElements();
    for (int i = 0; i < acum_res.size(); i++) {
        modeloresultados.addElement(acum_res.get(i));
     }
    lst_resultados.setModel(modeloresultados);
    acum_res.clear();        
           
           
           
           
           
       }
    }//GEN-LAST:event_rbtn_kmpActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        modelo.clear();
        lst_patrones.setModel(modelo);
        patterns.clear();
        modeloresultados.clear();
        acum_res.clear();
        lst_resultados.setModel(modeloresultados);
    }//GEN-LAST:event_jButton3ActionPerformed

    private void btn_agregarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_agregarActionPerformed
        if(txt_ingresar.getText()!=""){
            archivoTexto.add(txt_ingresar.getText());
            
            txt_ingresar.setEditable(false);
            btn_modificar.setVisible(true);
            btn_agregar.setVisible(false);
            
        }
        else{
            JOptionPane.showMessageDialog(null, "Debes llenar el campo texto!");
        }
    }//GEN-LAST:event_btn_agregarActionPerformed

    private void btn_modificarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn_modificarActionPerformed
        txt_ingresar.setEditable(true);
        archivoTexto.clear();
        btn_modificar.setVisible(false);
        btn_agregar.setVisible(true);
        modeloresultados.clear();
        acum_res.clear();
        lst_resultados.setModel(modeloresultados);
    }//GEN-LAST:event_btn_modificarActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Principal().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btn_agregar;
    private javax.swing.JToggleButton btn_importar;
    private javax.swing.JButton btn_ingresar_patron;
    private javax.swing.JButton btn_modificar;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JList<String> lst_patrones;
    private javax.swing.JList<String> lst_resultados;
    private javax.swing.JPanel pnl_importar;
    private javax.swing.JRadioButton rbtn_all;
    private javax.swing.JRadioButton rbtn_booyer;
    private javax.swing.JRadioButton rbtn_brute;
    private javax.swing.JRadioButton rbtn_importar;
    private javax.swing.JRadioButton rbtn_ingresar;
    private javax.swing.JRadioButton rbtn_kmp;
    private javax.swing.JTextField txt_ingresar;
    private javax.swing.JTextField txt_patron;
    // End of variables declaration//GEN-END:variables
   
    
    
    private static ArrayList<String> busquedaFuerzaBruta(String texto, String patron) {
        int lt = texto.length();
        int lP = patron.length();
        ArrayList<String> arrayPosiciones = new ArrayList<>();
        for (int q = 0; q <= (lt - lP); q++) { //iterar sober todo el texto
            int t = 0; //iterar el patron
            while (t < lP && texto.charAt(q+t) == patron.charAt(t)) {//Mientras t sea menor a la longitud del texto y el caracter(q+t) del texto
                //sea igual al caracter t del patron, se aumenta el valor de t
                t++;
            }
            if (t == lP) {//si t alcanza la longitud del patrón, entonces se encontró una coincidencia y por tanto se guarda esa coincidencia q en el array "arrayPosiciones"
                arrayPosiciones.add(q + " ");
            }
        }
        return arrayPosiciones;
    }
    //TODO *********************************** KMP***********************************************************
    public static ArrayList<String> busquedaKMP(char[] text, char[] pattern) {
        int n = text.length;
        int m = pattern.length;
        boolean comprobar = false;
        ArrayList<String> arrayPosiciones = new ArrayList<>();
        String strResultados = "";
        if (m == 0)
            return arrayPosiciones; // trivial search for empty string
        comprobar=false;
        int[] fail = computoFalloKMP(pattern); // computed by private utility
        //System.out.println(Arrays.toString(fail)); // Para visualizar el contenido de la funci�n de fallo.
        int j = 0; // index into text
        int k = 0; // index into pattern
        while (j < n) {
            if (text[j] == pattern[k]) { // pattern[0..k] matched thus far
                if (k == m - 1) {
                    strResultados += (j - m + 1) + ","; // match is complete
                    arrayPosiciones.add((j - m + 1) + ",");

                    k = 0;
                }
                j++; // otherwise, try to extend match
                k++;
            } else if (k > 0)
                k = fail[k - 1]; // reuse suffix of P[0..k-1]
            else
                j++;
        }

        return arrayPosiciones; // reached end without match
    }

    private static int[] computoFalloKMP(char[] pattern) {
        int m = pattern.length;
        int[] fail = new int[m]; // Mismo tama�o que el patr�n
        int j = 1;
        int k = 0;
        while (j < m) { // compute fail[j] during this pass, if nonzero
            if (pattern[j] == pattern[k]) { // k + 1 characters match thus far
                fail[j] = k + 1;
                j++;
                k++;
            } else if (k > 0) // k follows a matching prefix
                k = fail[k - 1];
            else // no match found starting at j
                j++;
        }
        return fail;
    }

    //------------------------------------------------------------------------------------------------------
    //ALGORITMO BOYER MOORE MEJORADO
    //-------------------------------------------------------------------------------------------------------
    static int NO_OF_CHARS = 256;

    //A utility function to get maximum of two integers
    static int max (int a, int b) { return (a > b)? a: b; }

    //The preprocessing function for Boyer Moore's
    //bad character heuristic
    static void badCharHeuristic( char []str, int size,int badchar[])
    {

        // Initialize all occurrences as -1
        for (int i = 0; i < NO_OF_CHARS; i++)
            badchar[i] = -1;

        // Fill the actual value of last occurrence
        // of a character (indices of table are ascii and values are index of occurrence)
        for (int i = 0; i < size; i++)
            badchar[(int) str[i]] = i;
    }

    /* A pattern searching function that uses Bad
    Character Heuristic of Boyer Moore Algorithm */
    static ArrayList<String> busquedaBoyerMoore( char txt[],  char pat[])
    {
        ArrayList<String> arrayPosiciones = new ArrayList<>();
        int m = pat.length;
        int n = txt.length;

        int badchar[] = new int[NO_OF_CHARS];

      /* Fill the bad character array by calling
         the preprocessing function badCharHeuristic()
         for given pattern */
        badCharHeuristic(pat, m, badchar);

        int s = 0;  // s is shift of the pattern with
        // respect to text
        //there are n-m+1 potential allignments
        while(s <= (n - m))
        {
            int j = m-1;

          /* Keep reducing index j of pattern while
             characters of pattern and text are
             matching at this shift s */
            while(j >= 0 && pat[j] == txt[s+j])
                j--;

          /* If the pattern is present at current
             shift, then index j will become -1 after
             the above loop */
            if (j < 0)
            {
                //System.out.println("Patterns occur at shift = " + s);
                arrayPosiciones.add(s + " ");
              /* Shift the pattern so that the next
                 character in text aligns with the last
                 occurrence of it in pattern.
                 The condition s+m < n is necessary for
                 the case when pattern occurs at the end
                 of text */
                //txt[s+m] is character after the pattern in text
                s += (s+m < n)? m-badchar[txt[s+m]] : 1;

            }

            else
              /* Shift the pattern so that the bad character
                 in text aligns with the last occurrence of
                 it in pattern. The max function is used to
                 make sure that we get a positive shift.
                 We may get a negative shift if the last
                 occurrence  of bad character in pattern
                 is on the right side of the current
                 character. */
                s += max(1, j - badchar[txt[s+j]]);
        }
        return arrayPosiciones;
    }
}
